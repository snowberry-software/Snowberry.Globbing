using Xunit.Abstractions;

namespace Snowberry.Globbing.Tests;

/// <summary>
/// Debug tests to verify specific patterns work correctly.
/// These document expected behavior and compare with JS picomatch.
/// </summary>
public class DebugTests
{
    private readonly ITestOutputHelper _output;

    public DebugTests(ITestOutputHelper output)
    {
        _output = output;
    }

    [Fact]
    public void Debug_TestDotXPattern()
    {
        var bashOpts = new GlobbingOptions { Bash = true };

        _output.WriteLine($"Pattern: **/.x/**");
        _output.WriteLine($"C# Regex: {GlobMatcher.MakeRe("**/.x/**", bashOpts)}");
        _output.WriteLine($"JS Regex: /^(?:(?:^|\\/|(?:(?:(?!(?:^|\\/)\\..).)*?)\\/))\\.x(?:\\/(?:(?:(?!(?:^|\\/)\\..).)*?)|$))$/");

        _output.WriteLine($".x/.x matches: {GlobMatcher.IsMatch(".x/.x", "**/.x/**", bashOpts)}");
        _output.WriteLine($".x matches: {GlobMatcher.IsMatch(".x", "**/.x/**", bashOpts)}");
        _output.WriteLine($"a/.x matches: {GlobMatcher.IsMatch("a/.x", "**/.x/**", bashOpts)}");
        _output.WriteLine($"a/b/.x/c matches: {GlobMatcher.IsMatch("a/b/.x/c", "**/.x/**", bashOpts)}");

        // Test the globstar regex pattern directly
        string globstarPattern = "**";
        _output.WriteLine($"\nGlobstar pattern: {globstarPattern}");
        _output.WriteLine($"C# Globstar Regex: {GlobMatcher.MakeRe(globstarPattern, bashOpts)}");
    }

    [Fact]
    public void Debug_ShowRegexPatterns()
    {
        // Output the regex patterns generated by C# to compare with JS
        string[] patterns = new[] { "c!(+)z", "c!(?)z", "/!(*.d).{ts,tsx}", "/!(*.d).@(ts)", "[!a]", "[[:alpha:]]+", "[a]+", "(a+|b)*", "a*+", "[a]+b", "[a-z]+", "a/**/", "**/.x/**" };
        string[] bashPatterns = new[] { "**/.x/**" };

        foreach (string? pattern in patterns)
        {
            try
            {
                var regex = GlobMatcher.MakeRe(pattern);
                _output.WriteLine($"Pattern: {pattern}");
                _output.WriteLine($"  C# Regex: {regex}");
                _output.WriteLine("");
            }
            catch (Exception ex)
            {
                _output.WriteLine($"Pattern: {pattern}");
                _output.WriteLine($"  ERROR: {ex.Message}");
                _output.WriteLine("");
            }
        }

        _output.WriteLine("=== Bash Mode ===");
        var bashOpts = new GlobbingOptions { Bash = true };
        foreach (string? pattern in bashPatterns)
        {
            try
            {
                var regex = GlobMatcher.MakeRe(pattern, bashOpts);
                _output.WriteLine($"Pattern (bash): {pattern}");
                _output.WriteLine($"  C# Regex: {regex}");
                _output.WriteLine("");
            }
            catch (Exception ex)
            {
                _output.WriteLine($"Pattern (bash): {pattern}");
                _output.WriteLine($"  ERROR: {ex.Message}");
                _output.WriteLine("");
            }
        }
    }

    [Fact]
    public void ExtglobWithBracket_ShouldMatch()
    {
        // Pattern: a@([.])b matches literal dot
        Assert.True(GlobMatcher.IsMatch("a.b", "a@([.])b"));
        Assert.False(GlobMatcher.IsMatch("a,b", "a@([.])b"));
    }

    [Fact]
    public void BracketWithPlusQuantifier_ShouldMatch()
    {
        // Pattern: [a]+ matches one or more 'a' characters
        Assert.True(GlobMatcher.IsMatch("a", "[a]+"));
        Assert.True(GlobMatcher.IsMatch("aa", "[a]+"));
        Assert.True(GlobMatcher.IsMatch("aaa", "[a]+"));
    }

    [Fact]
    public void PosixWithExtglob_ShouldMatch()
    {
        // Pattern: +([[:alpha:].]) matches one or more letters or dots
        var opts = new GlobbingOptions { Posix = true };
        Assert.True(GlobMatcher.IsMatch("a.c", "+([[:alpha:].])", opts));
    }

    [Fact]
    public void NoExtglob_ShouldTreatAsLiteral()
    {
        // With noextglob, @(foo) should be literal, not extglob
        var opts = new GlobbingOptions { NoExtglob = true };
        Assert.True(GlobMatcher.IsMatch("@(foo)", "@(foo)", opts));
        Assert.False(GlobMatcher.IsMatch("foo", "@(foo)", opts));
    }

    [Fact]
    public void NegationExtglobWithSlash_ShouldWork()
    {
        // Pattern: !(foo/bar) - negation extglob with slash inside
        Assert.True(GlobMatcher.IsMatch("foo", "!(foo/bar)"));
        Assert.False(GlobMatcher.IsMatch("foo/bar", "!(foo/bar)"));
        Assert.True(GlobMatcher.IsMatch("foo/baz", "!(foo/bar)"));
    }

    [Fact]
    public void RegexLikePattern_ShouldWork()
    {
        // Pattern: (a+|b)* - parentheses without extglob prefix
        Assert.True(GlobMatcher.IsMatch("ab", "(a+|b)*"));
        Assert.True(GlobMatcher.IsMatch("abab", "(a+|b)*"));
        Assert.True(GlobMatcher.IsMatch("abcdef", "(a+|b)*"));
        Assert.False(GlobMatcher.IsMatch("123abc", "(a+|b)*"));
    }

    [Fact]
    public void EscapedStar_ShouldMatchLiteralStar()
    {
        Assert.True(GlobMatcher.IsMatch("*", "\\*"));      // \* matches literal *
        Assert.True(GlobMatcher.IsMatch("\\*", "\\*"));    // Direct string comparison
        Assert.False(GlobMatcher.IsMatch("**", "\\*"));
        Assert.False(GlobMatcher.IsMatch("a", "\\*"));
    }

    [Fact]
    public void BackslashEscaping_InPosixMode()
    {
        // With Windows=false, backslash is escape character
        // Pattern \\ matches literal backslash
        var opts = new GlobbingOptions { Windows = false };
        Assert.True(GlobMatcher.IsMatch("\\", "\\\\", opts));
        Assert.True(GlobMatcher.IsMatch("a\\b", "a\\\\b", opts));
    }

    [Fact]
    public void DoubleQuote_ShouldMatchItself()
    {
        // Single double-quote matches itself via direct string comparison
        Assert.True(GlobMatcher.IsMatch("\"", "\""));
    }

    [Fact]
    public void SlashInBrackets_ShouldWork()
    {
        // foo[/]bar matches foo/bar
        Assert.True(GlobMatcher.IsMatch("foo/bar", "foo[/]bar"));
        Assert.False(GlobMatcher.IsMatch("foobar", "foo[/]bar"));
    }

    [Fact]
    public void TrailingSlashGlobstar_ShouldMatch()
    {
        // Pattern a/**/ should match a/b/c/d/ (path with trailing slash)
        Assert.True(GlobMatcher.IsMatch("a/b/c/d/", "a/**/"));
        Assert.True(GlobMatcher.IsMatch("a/", "a/**/"));
        Assert.False(GlobMatcher.IsMatch("a/b/c/d", "a/**/")); // No trailing slash - should NOT match
    }

    [Fact]
    public void Fixed_ExtglobNegationWithLiteralPlus()
    {
        // JS: pm.isMatch('cbz', 'c!(+)z') returns true
        // The + inside !(+) should be treated as literal plus, not regex quantifier
        // JS regex: /^(?:c(?:(?!(?:\+))[^/]*?)z)$/
        Assert.True(GlobMatcher.IsMatch("cbz", "c!(+)z"));
    }

    [Fact]
    public void Fixed_ExtglobNegationWithLiteralQuestionMark()
    {
        // JS: pm.isMatch('cbz', 'c!(?)z') returns true
        // The ? inside !(?) should be treated as literal question mark, not regex quantifier
        Assert.True(GlobMatcher.IsMatch("cbz", "c!(?)z"));
    }

    [Fact]
    public void Fixed_NegationExtglobWithBraces()
    {
        // JS: pm.isMatch('/file.d.ts', '/!(*.d).{ts,tsx}') returns false
        // The negation should exclude files ending in .d before .ts/.tsx
        Assert.False(GlobMatcher.IsMatch("/file.d.ts", "/!(*.d).{ts,tsx}"));
        Assert.True(GlobMatcher.IsMatch("/file.ts", "/!(*.d).{ts,tsx}"));
    }

    [Fact]
    public void Fixed_NegationExtglobWithAtExtglob()
    {
        // JS: pm.isMatch('/file.d.ts', '/!(*.d).@(ts)') returns false
        Assert.False(GlobMatcher.IsMatch("/file.d.ts", "/!(*.d).@(ts)"));
        Assert.True(GlobMatcher.IsMatch("/file.ts", "/!(*.d).@(ts)"));
    }

    [Fact]
    public void BracketNegation_UsesCaretNotExclamation()
    {
        Assert.True(GlobMatcher.IsMatch("[!a]", "[!a]"));
        Assert.True(GlobMatcher.IsMatch("a", "[!a]"));
        Assert.False(GlobMatcher.IsMatch("b", "[!a]"));

        // [^a] is proper negation
        Assert.True(GlobMatcher.IsMatch("b", "[^a]"));
        Assert.False(GlobMatcher.IsMatch("a", "[^a]"));
    }

    [Fact]
    public void Fixed_PosixClassWithPlusQuantifier()
    {
        // JS: pm.isMatch('abc', '[[:alpha:]]+') returns true
        // The + after POSIX class should work as quantifier
        var opts = new GlobbingOptions { Posix = true };
        Assert.True(GlobMatcher.IsMatch("abc", "[[:alpha:]]+", opts));
        Assert.True(GlobMatcher.IsMatch("a", "[[:alpha:]]+", opts));
    }

}
