namespace Snowberry.Globbing.Tests;

/// <summary>
/// Tests for globstar (**) patterns ported from picomatch.
/// </summary>
public class GlobstarsTests
{
    [Theory]
    [InlineData("a/b/c/d.js", "**/*.js", true)]
    [InlineData("a/b/c.js", "**/*.js", true)]
    [InlineData("a/b.js", "**/*.js", true)]
    [InlineData("a/b/c/d/e/f.js", "a/b/**/*.js", true)]
    [InlineData("a/b/c/d/e.js", "a/b/**/*.js", true)]
    [InlineData("a/b/c/d.js", "a/b/c/**/*.js", true)]
    [InlineData("a/b/c/d.js", "a/b/**/*.js", true)]
    [InlineData("a/b/d.js", "a/b/**/*.js", true)]
    [InlineData("a/d.js", "a/b/**/*.js", false)]
    [InlineData("d.js", "a/b/**/*.js", false)]
    public void ShouldMatchGlobstars(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("a/b/c", "**c", false)]
    [InlineData("a/b/c", "a/**c", false)]
    [InlineData("a/b/c", "a/**z", false)]
    [InlineData("a/b/c/b/c", "a/**b**/c", false)]
    [InlineData("a/b/c/d/e.js", "a/b/c**/*.js", false)]
    [InlineData("aaa/bba/ccc", "aaa/**ccc", false)]
    [InlineData("aaa/bba/ccc", "aaa/**z", false)]
    [InlineData("a/b/c/b/c", "a/**/b/**/c", true)]
    [InlineData("a/aba/c", "a/**b**/c", true)]
    [InlineData("a/b/c", "a/**b**/c", true)]
    [InlineData("a/b/c/d.js", "a/b/c**/*.js", true)]
    [InlineData("aaa/bba/ccc", "aaa/**b**/ccc", true)]
    public void ShouldRegardNonExclusiveDoubleStarsAsSingleStars(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("a", "a/**/*", false)]
    [InlineData("a", "a/**/**/*", false)]
    [InlineData("a", "a/**/**/**/*", false)]
    [InlineData("a/", "**/a", false)]
    [InlineData("a/", "a/**/*", false)]
    [InlineData("a/", "a/**/**/*", false)]
    [InlineData("a/", "a/**/**/**/*", false)]
    [InlineData("a/b", "**/a", false)]
    [InlineData("a/b/c/j/e/z/c.txt", "a/**/j/**/z/*.md", false)]
    [InlineData("a/bb", "a/**/b", false)]
    [InlineData("a/c", "**/a", false)]
    [InlineData("a/x/y", "**/a", false)]
    [InlineData("a/b/c/d", "**/a", false)]
    [InlineData("a", "**", true)]
    [InlineData("a", "**/a", true)]
    [InlineData("a", "a/**", true)]
    [InlineData("a/", "**", true)]
    [InlineData("a/", "**/a/**", true)]
    [InlineData("a/", "a/**", true)]
    [InlineData("a/", "a/**/**", true)]
    [InlineData("a/a", "**/a", true)]
    [InlineData("a/b", "**", true)]
    [InlineData("a/b", "*/*", true)]
    [InlineData("a/b", "a/**", true)]
    [InlineData("a/b", "a/**/*", true)]
    [InlineData("a/b", "a/**/**/*", true)]
    [InlineData("a/b", "a/**/**/**/*", true)]
    [InlineData("a/b", "a/**/b", true)]
    [InlineData("a/b/c", "**", true)]
    [InlineData("a/b/c", "**/*", true)]
    [InlineData("a/b/c", "**/**", true)]
    [InlineData("a/b/c", "*/**", true)]
    [InlineData("a/b/c", "a/**", true)]
    [InlineData("a/b/c", "a/**/*", true)]
    [InlineData("a/b/c", "a/**/**/*", true)]
    [InlineData("a/b/c", "a/**/**/**/*", true)]
    [InlineData("a/b/c/d", "**", true)]
    [InlineData("a/b/c/d", "a/**", true)]
    [InlineData("a/b/c/d", "a/**/*", true)]
    [InlineData("a/b/c/d", "a/**/**/*", true)]
    [InlineData("a/b/c/d", "a/**/**/**/*", true)]
    [InlineData("a/b/c/d.e", "a/b/**/c/**/*.*", true)]
    [InlineData("a/b/c/d/e/f/g.md", "a/**/f/*.md", true)]
    [InlineData("a/b/c/d/e/f/g/h/i/j/k/l.md", "a/**/f/**/k/*.md", true)]
    [InlineData("a/b/c/def.md", "a/b/c/*.md", true)]
    [InlineData("a/bb.bb/c/ddd.md", "a/*/c/*.md", true)]
    [InlineData("a/bb.bb/cc/d.d/ee/f/ggg.md", "a/**/f/*.md", true)]
    [InlineData("a/bb.bb/cc/dd/ee/f/ggg.md", "a/**/f/*.md", true)]
    [InlineData("a/bb/c/ddd.md", "a/*/c/*.md", true)]
    [InlineData("a/bbbb/c/ddd.md", "a/*/c/*.md", true)]
    public void ShouldSupportGlobstars(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("a/b/c/d/e/z/foo.md", "a/**/c/**{,(/z|/x)}/*.md", true)]
    [InlineData("a/b/c/d/e/z/foo.md", "a/**{,(/x|/z)}/*.md", true)]
    public void ShouldSupportGlobstarsFollowedByBraces(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("/x/foo.md", "@(/x|/z)/*.md", true)]
    [InlineData("/z/foo.md", "@(/x|/z)/*.md", true)]
    [InlineData("a/b/c/d/e/z/foo.md", "a/**/c/**@(/z|/x)/*.md", true)]
    [InlineData("a/b/c/d/e/z/foo.md", "a/**@(/x|/z)/*.md", true)]
    public void ShouldSupportGlobstarsFollowedByBracesWithNestedExtglobs(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("a/b/c/d/e/z/foo.md", "a/**/j/**/z/*.md", false)]
    [InlineData("a/b/c/j/e/z/foo.txt", "a/**/j/**/z/*.md", false)]
    [InlineData("a/b/c/d/e/j/n/p/o/z/foo.md", "a/**/j/**/z/*.md", true)]
    [InlineData("a/b/c/d/e/z/foo.md", "a/**/z/*.md", true)]
    [InlineData("a/b/c/j/e/z/foo.md", "a/**/j/**/z/*.md", true)]
    public void ShouldSupportMultipleGlobstarsInOnePattern(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData(".a/a", "**", false)]
    [InlineData("a/.a", "**", false)]
    [InlineData(".a/a", "**/", false)]
    [InlineData("a/.a", "**/", false)]
    [InlineData(".a/a", "**/**", false)]
    [InlineData("a/.a", "**/**", false)]
    [InlineData(".a/a", "**/**/*", false)]
    [InlineData("a/.a", "**/**/*", false)]
    [InlineData(".a/a", "**/**/x", false)]
    [InlineData("a/.a", "**/**/x", false)]
    [InlineData(".a/a", "**/x", false)]
    [InlineData("a/.a", "**/x", false)]
    [InlineData(".a/a", "**/x/*", false)]
    [InlineData("a/.a", "**/x/*", false)]
    [InlineData(".a/a", "**/x/**", false)]
    [InlineData("a/.a", "**/x/**", false)]
    [InlineData(".a/a", "**/x/*/*", false)]
    [InlineData("a/.a", "**/x/*/*", false)]
    [InlineData(".a/a", "*/x/**", false)]
    [InlineData("a/.a", "*/x/**", false)]
    [InlineData(".a/a", "a/**", false)]
    [InlineData("a/.a", "a/**", false)]
    [InlineData(".a/a", "a/**/*", false)]
    [InlineData("a/.a", "a/**/*", false)]
    [InlineData(".a/a", "a/**/**/*", false)]
    [InlineData("a/.a", "a/**/**/*", false)]
    [InlineData(".a/a", "b/**", false)]
    [InlineData("a/.a", "b/**", false)]
    public void SingleDots(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("a/../a", "**", false)]
    [InlineData("ab/../ac", "**", false)]
    [InlineData("../a", "**", false)]
    [InlineData("../../b", "**", false)]
    [InlineData("../c", "**", false)]
    [InlineData("../c/d", "**", false)]
    [InlineData("a/../a", "**/", false)]
    [InlineData("ab/../ac", "**/", false)]
    [InlineData("../a", "**/", false)]
    [InlineData("../../b", "**/", false)]
    [InlineData("../c", "**/", false)]
    [InlineData("../c/d", "**/", false)]
    [InlineData("a/../a", "**/**", false)]
    [InlineData("ab/../ac", "**/**", false)]
    [InlineData("../a", "**/**", false)]
    [InlineData("../../b", "**/**", false)]
    [InlineData("../c", "**/**", false)]
    [InlineData("../c/d", "**/**", false)]
    [InlineData("a/../a", "**/**/*", false)]
    [InlineData("ab/../ac", "**/**/*", false)]
    [InlineData("../a", "**/**/*", false)]
    [InlineData("../../b", "**/**/*", false)]
    [InlineData("../c", "**/**/*", false)]
    [InlineData("../c/d", "**/**/*", false)]
    [InlineData("a/../a", "**/**/x", false)]
    [InlineData("ab/../ac", "**/**/x", false)]
    [InlineData("../a", "**/**/x", false)]
    [InlineData("../../b", "**/**/x", false)]
    [InlineData("../c", "**/**/x", false)]
    [InlineData("../c/d", "**/**/x", false)]
    [InlineData("a/../a", "**/x", false)]
    [InlineData("ab/../ac", "**/x", false)]
    [InlineData("../a", "**/x", false)]
    [InlineData("../../b", "**/x", false)]
    [InlineData("../c", "**/x", false)]
    [InlineData("../c/d", "**/x", false)]
    [InlineData("a/../a", "**/x/*", false)]
    [InlineData("ab/../ac", "**/x/*", false)]
    [InlineData("../a", "**/x/*", false)]
    [InlineData("../../b", "**/x/*", false)]
    [InlineData("../c", "**/x/*", false)]
    [InlineData("../c/d", "**/x/*", false)]
    [InlineData("a/../a", "**/x/**", false)]
    [InlineData("ab/../ac", "**/x/**", false)]
    [InlineData("../a", "**/x/**", false)]
    [InlineData("../../b", "**/x/**", false)]
    [InlineData("../c", "**/x/**", false)]
    [InlineData("../c/d", "**/x/**", false)]
    [InlineData("a/../a", "**/x/*/*", false)]
    [InlineData("ab/../ac", "**/x/*/*", false)]
    [InlineData("../a", "**/x/*/*", false)]
    [InlineData("../../b", "**/x/*/*", false)]
    [InlineData("../c", "**/x/*/*", false)]
    [InlineData("../c/d", "**/x/*/*", false)]
    [InlineData("a/../a", "*/x/**", false)]
    [InlineData("ab/../ac", "*/x/**", false)]
    [InlineData("../a", "*/x/**", false)]
    [InlineData("../../b", "*/x/**", false)]
    [InlineData("../c", "*/x/**", false)]
    [InlineData("../c/d", "*/x/**", false)]
    [InlineData("a/../a", "a/**", false)]
    [InlineData("ab/../ac", "a/**", false)]
    [InlineData("../a", "a/**", false)]
    [InlineData("../../b", "a/**", false)]
    [InlineData("../c", "a/**", false)]
    [InlineData("../c/d", "a/**", false)]
    [InlineData("a/../a", "a/**/*", false)]
    [InlineData("ab/../ac", "a/**/*", false)]
    [InlineData("../a", "a/**/*", false)]
    [InlineData("../../b", "a/**/*", false)]
    [InlineData("../c", "a/**/*", false)]
    [InlineData("../c/d", "a/**/*", false)]
    [InlineData("a/../a", "a/**/**/*", false)]
    [InlineData("ab/../ac", "a/**/**/*", false)]
    [InlineData("../a", "a/**/**/*", false)]
    [InlineData("../../b", "a/**/**/*", false)]
    [InlineData("../c", "a/**/**/*", false)]
    [InlineData("../c/d", "a/**/**/*", false)]
    [InlineData("a/../a", "b/**", false)]
    [InlineData("ab/../ac", "b/**", false)]
    [InlineData("../a", "b/**", false)]
    [InlineData("../../b", "b/**", false)]
    [InlineData("../c", "b/**", false)]
    [InlineData("../c/d", "b/**", false)]
    public void DoubleDots(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("a", "**/", false)]
    [InlineData("a", "**/a/*", false)]
    [InlineData("a", "**/a/*/*", false)]
    [InlineData("a", "*/a/**", false)]
    [InlineData("a", "a/**/*", false)]
    [InlineData("a", "a/**/**/*", false)]
    [InlineData("a/b", "**/", false)]
    [InlineData("a/b", "**/b/*", false)]
    [InlineData("a/b", "**/b/*/*", false)]
    [InlineData("a/b", "b/**", false)]
    [InlineData("a/b/c", "**/", false)]
    [InlineData("a/b/c", "**/**/b", false)]
    [InlineData("a/b/c", "**/b", false)]
    [InlineData("a/b/c", "**/b/*/*", false)]
    [InlineData("a/b/c", "b/**", false)]
    [InlineData("a/b/c/d", "**/", false)]
    [InlineData("a/b/c/d", "**/d/*", false)]
    [InlineData("a/b/c/d", "b/**", false)]
    [InlineData("a", "**", true)]
    [InlineData("a", "**/**", true)]
    [InlineData("a", "**/**/*", true)]
    [InlineData("a", "**/**/a", true)]
    [InlineData("a", "**/a", true)]
    [InlineData("a", "**/a/**", true)]
    [InlineData("a", "a/**", true)]
    [InlineData("a/b", "**", true)]
    [InlineData("a/b", "**/**", true)]
    [InlineData("a/b", "**/**/*", true)]
    [InlineData("a/b", "**/**/b", true)]
    [InlineData("a/b", "**/b", true)]
    [InlineData("a/b", "**/b/**", true)]
    [InlineData("a/b", "*/b/**", true)]
    [InlineData("a/b", "a/**", true)]
    [InlineData("a/b", "a/**/*", true)]
    [InlineData("a/b", "a/**/**/*", true)]
    [InlineData("a/b/c", "**", true)]
    [InlineData("a/b/c", "**/**", true)]
    [InlineData("a/b/c", "**/**/*", true)]
    [InlineData("a/b/c", "**/b/*", true)]
    [InlineData("a/b/c", "**/b/**", true)]
    [InlineData("a/b/c", "*/b/**", true)]
    [InlineData("a/b/c", "a/**", true)]
    [InlineData("a/b/c", "a/**/*", true)]
    [InlineData("a/b/c", "a/**/**/*", true)]
    [InlineData("a/b/c/d", "**", true)]
    [InlineData("a/b/c/d", "**/**", true)]
    [InlineData("a/b/c/d", "**/**/*", true)]
    [InlineData("a/b/c/d", "**/**/d", true)]
    [InlineData("a/b/c/d", "**/b/**", true)]
    [InlineData("a/b/c/d", "**/b/*/*", true)]
    [InlineData("a/b/c/d", "**/d", true)]
    [InlineData("a/b/c/d", "*/b/**", true)]
    [InlineData("a/b/c/d", "a/**", true)]
    [InlineData("a/b/c/d", "a/**/*", true)]
    [InlineData("a/b/c/d", "a/**/**/*", true)]
    public void ShouldMatch(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("a/b", "*/*", true)]
    [InlineData("a/b/c/xyz.md", "a/b/c/*.md", true)]
    [InlineData("a/bb.bb/c/xyz.md", "a/*/c/*.md", true)]
    [InlineData("a/bb/c/xyz.md", "a/*/c/*.md", true)]
    [InlineData("a/bbbb/c/xyz.md", "a/*/c/*.md", true)]
    [InlineData("a/b/c", "**/*", true)]
    [InlineData("a/b/c", "**/**", true)]
    [InlineData("a/b/c", "*/**", true)]
    [InlineData("a/b/c/d/e/j/n/p/o/z/c.md", "a/**/j/**/z/*.md", true)]
    [InlineData("a/b/c/d/e/z/c.md", "a/**/z/*.md", true)]
    [InlineData("a/bb.bb/aa/b.b/aa/c/xyz.md", "a/**/c/*.md", true)]
    [InlineData("a/bb.bb/aa/bb/aa/c/xyz.md", "a/**/c/*.md", true)]
    [InlineData("a/b/c/j/e/z/c.txt", "a/**/j/**/z/*.md", false)]
    [InlineData("a/b/c/xyz.md", "a/b/**/c{d,e}/**/xyz.md", false)]
    [InlineData("a/b/d/xyz.md", "a/b/**/c{d,e}/**/xyz.md", false)]
    [InlineData("a/b", "a/**/", false)]
    [InlineData("a/b/.js/c.txt", "**/*", false)]
    [InlineData("a/b/c/d", "a/**/", false)]
    [InlineData("a/bb", "a/**/", false)]
    [InlineData("a/cb", "a/**/", false)]
    [InlineData("/a/b", "/**", true)]
    [InlineData("a.b", "**/*", true)]
    [InlineData("a.js", "**/*", true)]
    [InlineData("a.js", "**/*.js", true)]
    [InlineData("a/", "a/**/", true)]
    [InlineData("a/a.js", "**/*.js", true)]
    [InlineData("a/a/b.js", "**/*.js", true)]
    [InlineData("a/b", "a/**/b", true)]
    [InlineData("a/b", "a/**b", true)]
    [InlineData("a/b.md", "**/*.md", true)]
    [InlineData("a/b/c.js", "**/*", true)]
    [InlineData("a/b/c.txt", "**/*", true)]
    [InlineData("a/b/c/d/", "a/**/", true)]
    [InlineData("a/b/c/d/a.js", "**/*", true)]
    [InlineData("a/b/c/z.js", "a/b/**/*.js", true)]
    [InlineData("a/b/z.js", "a/b/**/*.js", true)]
    [InlineData("ab", "**/*", true)]
    [InlineData("ab/c", "**/*", true)]
    [InlineData("ab/c/d", "**/*", true)]
    [InlineData("abc.js", "**/*", true)]
    public void ShouldMatchNestedDirectories(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("a/.b", "a/**/z/*.md", false)]
    [InlineData("a/b/z/.a", "a/**/z/*.a", false)]
    [InlineData("a/b/z/.a", "a/*/z/*.a", false)]
    [InlineData("a/b/z/.a", "b/a", false)]
    [InlineData("a/foo/z/.b", "a/**/z/*.md", false)]
    public void ShouldNotMatchDotfilesByDefault(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData(".gitignore", "a/**/z/*.md", false)]
    [InlineData("a/b/z/.dotfile", "a/**/z/*.md", false)]
    [InlineData("a/b/z/.dotfile.md", "**/c/.*.md", false)]
    [InlineData("a/.b", "a/.*", true)]
    [InlineData("a/b/z/.a", "a/*/z/.a", true)]
    [InlineData("a/b/z/.dotfile.md", "**/.*.md", true)]
    [InlineData("a/b/z/.dotfile.md", "a/**/z/.*.md", true)]
    public void ShouldMatchLeadingDotsWhenDefinedInPattern(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }

    [Theory]
    [InlineData("foo/bar/baz/one/image.png", "foo/bar/**/one/**/*.*", true)]
    [InlineData("foo/bar/baz/one/two/image.png", "foo/bar/**/one/**/*.*", true)]
    [InlineData("foo/bar/baz/one/two/three/image.png", "foo/bar/**/one/**/*.*", true)]
    [InlineData("a/b/c/d/", "a/b/**/f", false)]
    [InlineData("a", "a/**", true)]
    [InlineData("a", "**", true)]
    [InlineData("a", "a{,/**}", true)]
    [InlineData("a/", "**", true)]
    [InlineData("a/", "a/**", true)]
    [InlineData("a/b/c/d", "**", true)]
    [InlineData("a/b/c/d/", "**", true)]
    [InlineData("a/b/c/d/", "**/**", true)]
    [InlineData("a/b/c/d/", "**/b/**", true)]
    [InlineData("a/b/c/d/", "a/b/**", true)]
    [InlineData("a/b/c/d/", "a/b/**/", true)]
    [InlineData("a/b/c/d/", "a/b/**/c/**/", true)]
    [InlineData("a/b/c/d/", "a/b/**/c/**/d/", true)]
    [InlineData("a/b/c/d/e.f", "a/b/**/**/*.*", true)]
    [InlineData("a/b/c/d/e.f", "a/b/**/*.*", true)]
    [InlineData("a/b/c/d/e.f", "a/b/**/c/**/d/*.*", true)]
    [InlineData("a/b/c/d/e.f", "a/b/**/d/**/*.*", true)]
    [InlineData("a/b/c/d/g/e.f", "a/b/**/d/**/*.*", true)]
    [InlineData("a/b/c/d/g/g/e.f", "a/b/**/d/**/*.*", true)]
    [InlineData("a/b-c/z.js", "a/b-*/**/z.js", true)]
    [InlineData("a/b-c/d/e/z.js", "a/b-*/**/z.js", true)]
    public void TodoMicromatchIssue24(string input, string pattern, bool expected)
    {
        Assert.Equal(expected, GlobMatcher.IsMatch(input, pattern));
    }
}
